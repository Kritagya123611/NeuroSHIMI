declare const _default: "#pragma version 10\n\nzorkin_contract_account.contracts.jwt_contents_proof_verifier.jwt_contents_proof_verifier:\n    // zorkin_contract_account/contracts/jwt_contents_proof_verifier.py:25-26\n    // # Unpack the input\n    // proof_a: Bytes = arg(0)\n    arg 0\n    // zorkin_contract_account/contracts/jwt_contents_proof_verifier.py:22-23\n    // # LSIG Hardcoded GUID of the Zorkin Verifier\n    // verifier_params_hash: Bytes = TemplateVar[Bytes](\"VERIFIER_GUID\")\n    byte TMPL_VERIFIER_GUID\n    // zorkin_contract_account/contracts/jwt_contents_proof_verifier.py:27\n    // proof_b: Bytes = arg(1)\n    arg 1\n    // zorkin_contract_account/contracts/jwt_contents_proof_verifier.py:28\n    // proof_c: Bytes = arg(2)\n    arg 2\n    // zorkin_contract_account/contracts/jwt_contents_proof_verifier.py:30\n    // input_data_from_notes: Bytes = aggregate_gtxn_notes()\n    callsub aggregate_gtxn_notes\n    // zorkin_contract_account/contracts/jwt_contents_proof_verifier.py:35\n    // contract_account_params.jwt_contents_verifier_params.bytes\n    dup\n    int 114\n    extract_uint16\n    swap\n    dup\n    int 116\n    extract_uint16\n    dig 1\n    uncover 3\n    uncover 2\n    substring3\n    // zorkin_contract_account/contracts/jwt_contents_proof_verifier.py:34-36\n    // verifier_params_bytes: Bytes = decode_dynamic_bytes(\n    //     contract_account_params.jwt_contents_verifier_params.bytes\n    // )\n    callsub decode_dynamic_bytes\n    swap\n    // zorkin_contract_account/contracts/jwt_contents_proof_verifier.py:39\n    // contract_account_params.jwt_contents_public_input.bytes\n    dup\n    int 110\n    extract_uint16\n    swap\n    dup\n    int 112\n    extract_uint16\n    swap\n    cover 2\n    substring3\n    // zorkin_contract_account/contracts/jwt_contents_proof_verifier.py:38-40\n    // public_input: Bytes = decode_dynamic_bytes(\n    //     contract_account_params.jwt_contents_public_input.bytes\n    // )\n    callsub decode_dynamic_bytes\n    swap\n    // zorkin_contract_account/contracts/jwt_contents_proof_verifier.py:42\n    // vk_alpha: Bytes = verifier_params.alpha.bytes\n    dup\n    extract 0 64 // on error: Index access is out of bounds\n    swap\n    // zorkin_contract_account/contracts/jwt_contents_proof_verifier.py:43\n    // vk_beta: Bytes = verifier_params.beta.bytes\n    dup\n    extract 64 128 // on error: Index access is out of bounds\n    swap\n    // zorkin_contract_account/contracts/jwt_contents_proof_verifier.py:44\n    // vk_gamma: Bytes = verifier_params.gamma.bytes\n    dup\n    extract 192 128 // on error: Index access is out of bounds\n    swap\n    // zorkin_contract_account/contracts/jwt_contents_proof_verifier.py:45\n    // vk_delta: Bytes = verifier_params.delta.bytes\n    dup\n    int 320\n    int 128\n    extract3 // on error: Index access is out of bounds\n    swap\n    // zorkin_contract_account/contracts/jwt_contents_proof_verifier.py:46\n    // vk_ic: Bytes = decode_dynamic_bytes(verifier_params.ic.bytes)\n    dup\n    int 448\n    extract_uint16\n    swap\n    dup\n    len\n    swap\n    cover 2\n    substring3\n    callsub decode_dynamic_bytes\n    // zorkin_contract_account/contracts/jwt_contents_proof_verifier.py:47-58\n    // proof_is_valid_for_verifier: bool = verify_proof(\n    //     vk_alpha,\n    //     vk_beta,\n    //     vk_gamma,\n    //     vk_delta,\n    //     vk_ic,\n    //     verifier_params_hash,\n    //     public_input,\n    //     proof_a,\n    //     proof_b,\n    //     proof_c,\n    // )\n    uncover 8\n    uncover 6\n    uncover 9\n    uncover 9\n    uncover 9\n    callsub verify_proof\n    // zorkin_contract_account/contracts/jwt_contents_proof_verifier.py:60\n    // assert proof_is_valid_for_verifier, \"Proof must be valid for specified verifier\"\n    dup\n    assert // Proof must be valid for specified verifier\n    // zorkin_contract_account/contracts/jwt_contents_proof_verifier.py:61\n    // return proof_is_valid_for_verifier\n    return\n\n\n// zorkin_contract_account.common.aggregate_gtxn_notes() -> bytes:\naggregate_gtxn_notes:\n    // zorkin_contract_account/common.py:165-166\n    // @subroutine\n    // def aggregate_gtxn_notes() -> Bytes:\n    proto 0 1\n    // zorkin_contract_account/common.py:167\n    // data: Bytes = Bytes(b\"\")\n    byte 0x\n    // zorkin_contract_account/common.py:168\n    // group_size: UInt64 = Global.group_size\n    global GroupSize\n    // zorkin_contract_account/common.py:169\n    // for i in urange(group_size):\n    int 0\n\naggregate_gtxn_notes_for_header@1:\n    // zorkin_contract_account/common.py:169\n    // for i in urange(group_size):\n    frame_dig 2\n    frame_dig 1\n    <\n    bz aggregate_gtxn_notes_after_for@4\n    // zorkin_contract_account/common.py:170\n    // note: Bytes = gtxn.Transaction(i).note\n    frame_dig 2\n    dup\n    gtxns Note\n    // zorkin_contract_account/common.py:171\n    // data += note\n    frame_dig 0\n    swap\n    concat\n    frame_bury 0\n    // zorkin_contract_account/common.py:169\n    // for i in urange(group_size):\n    int 1\n    +\n    frame_bury 2\n    b aggregate_gtxn_notes_for_header@1\n\naggregate_gtxn_notes_after_for@4:\n    // zorkin_contract_account/common.py:172\n    // return data\n    retsub\n\n\n// zorkin_contract_account.common.decode_dynamic_bytes(value: bytes) -> bytes:\ndecode_dynamic_bytes:\n    // zorkin_contract_account/common.py:83-84\n    // @subroutine\n    // def decode_dynamic_bytes(value: Bytes) -> Bytes:\n    proto 1 1\n    // zorkin_contract_account/common.py:85\n    // return substring(value, 2, value.length)\n    frame_dig -1\n    len\n    frame_dig -1\n    int 2\n    uncover 2\n    substring3\n    retsub\n\n\n// zorkin_contract_account.verifier.verify_proof(vk_alpha: bytes, vk_beta: bytes, vk_gamma: bytes, vk_delta: bytes, vk_ic: bytes, verifier_params_integrity_hash: bytes, public_input: bytes, proof_a: bytes, proof_b: bytes, proof_c: bytes) -> uint64:\nverify_proof:\n    // zorkin_contract_account/verifier.py:67-79\n    // @subroutine\n    // def verify_proof(\n    //     vk_alpha: Bytes,\n    //     vk_beta: Bytes,\n    //     vk_gamma: Bytes,\n    //     vk_delta: Bytes,\n    //     vk_ic: Bytes,\n    //     verifier_params_integrity_hash: Bytes,\n    //     public_input: Bytes,\n    //     proof_a: Bytes,\n    //     proof_b: Bytes,\n    //     proof_c: Bytes,\n    // ) -> bool:\n    proto 10 1\n    // zorkin_contract_account/verifier.py:80\n    // n_input: UInt64 = public_input.length // KEY_SIZE\n    frame_dig -4\n    len\n    int 32\n    /\n    // zorkin_contract_account/verifier.py:81\n    // beta_gamma_delta: Bytes = concat(vk_beta, concat(vk_gamma, vk_delta))\n    frame_dig -8\n    frame_dig -7\n    concat\n    frame_dig -9\n    swap\n    concat\n    dup\n    // zorkin_contract_account/verifier.py:85\n    // sha256(concat(concat(vk_alpha, beta_gamma_delta), vk_ic))\n    frame_dig -10\n    swap\n    concat\n    frame_dig -6\n    concat\n    sha256\n    // zorkin_contract_account/verifier.py:83-87\n    // # Assert it's the specified verifier by comparing it to a known integrity hash\n    // vk_is_valid: bool = (\n    //     sha256(concat(concat(vk_alpha, beta_gamma_delta), vk_ic))\n    //     == verifier_params_integrity_hash\n    // )\n    frame_dig -5\n    // zorkin_contract_account/verifier.py:85-86\n    // sha256(concat(concat(vk_alpha, beta_gamma_delta), vk_ic))\n    // == verifier_params_integrity_hash\n    ==\n    // zorkin_contract_account/verifier.py:89-90\n    // # Get vk_x\n    // vk_x: Bytes = concat(bzero(32), bzero(32))\n    byte 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n    // zorkin_contract_account/verifier.py:91\n    // for i in urange(n_input):\n    int 0\n\nverify_proof_for_header@1:\n    // zorkin_contract_account/verifier.py:91\n    // for i in urange(n_input):\n    frame_dig 4\n    frame_dig 0\n    <\n    bz verify_proof_after_for@4\n    // zorkin_contract_account/verifier.py:97\n    // extract(vk_ic, KEY_SIZE * (i + 1) * 2, KEY_SIZE * 2),\n    frame_dig 4\n    dup\n    int 1\n    +\n    int 32\n    dig 1\n    *\n    int 2\n    *\n    frame_dig -6\n    swap\n    int 64\n    extract3\n    // zorkin_contract_account/verifier.py:98\n    // extract(public_input, KEY_SIZE * i, KEY_SIZE),\n    int 32\n    uncover 3\n    *\n    frame_dig -4\n    swap\n    int 32\n    extract3\n    // zorkin_contract_account/verifier.py:95-99\n    // EllipticCurve.scalar_mul(\n    //     EC.BN254g1,\n    //     extract(vk_ic, KEY_SIZE * (i + 1) * 2, KEY_SIZE * 2),\n    //     extract(public_input, KEY_SIZE * i, KEY_SIZE),\n    // ),\n    ec_scalar_mul BN254g1\n    // zorkin_contract_account/verifier.py:92-100\n    // vk_x = EllipticCurve.add(\n    //     EC.BN254g1,\n    //     vk_x,\n    //     EllipticCurve.scalar_mul(\n    //         EC.BN254g1,\n    //         extract(vk_ic, KEY_SIZE * (i + 1) * 2, KEY_SIZE * 2),\n    //         extract(public_input, KEY_SIZE * i, KEY_SIZE),\n    //     ),\n    // )\n    frame_dig 3\n    swap\n    ec_add BN254g1\n    frame_bury 3\n    frame_bury 4\n    b verify_proof_for_header@1\n\nverify_proof_after_for@4:\n    // zorkin_contract_account/verifier.py:101\n    // vk_x = EllipticCurve.add(EC.BN254g1, vk_x, extract(vk_ic, 0, KEY_SIZE * 2))\n    frame_dig -6\n    extract 0 64\n    frame_dig 3\n    swap\n    ec_add BN254g1\n    // zorkin_contract_account/verifier.py:103-104\n    // # Negate Proof\n    // negated_proof: Bytes = _negate_proof(proof_a)\n    frame_dig -3\n    callsub _negate_proof\n    // zorkin_contract_account/verifier.py:106-107\n    // # Verify Proof\n    // proof_b_with_params: Bytes = concat(proof_b, beta_gamma_delta)\n    frame_dig -2\n    frame_dig 1\n    concat\n    cover 2\n    // zorkin_contract_account/verifier.py:111\n    // concat(concat(negated_proof, vk_alpha), concat(vk_x, proof_c)),\n    frame_dig -10\n    concat\n    swap\n    frame_dig -1\n    concat\n    concat\n    // zorkin_contract_account/verifier.py:109-113\n    // verify_proof: bool = EllipticCurve.pairing_check(\n    //     EC.BN254g1,\n    //     concat(concat(negated_proof, vk_alpha), concat(vk_x, proof_c)),\n    //     proof_b_with_params,\n    // )\n    swap\n    ec_pairing_check BN254g1\n    // zorkin_contract_account/verifier.py:115\n    // return vk_is_valid and verify_proof\n    frame_dig 2\n    &&\n    frame_bury 0\n    retsub\n\n\n// zorkin_contract_account.verifier._negate_proof(g1: bytes) -> bytes:\n_negate_proof:\n    // zorkin_contract_account/verifier.py:60-61\n    // @subroutine\n    // def _negate_proof(g1: Bytes) -> Bytes:\n    proto 1 1\n    // zorkin_contract_account/verifier.py:62\n    // negated_rhs: Bytes = _negate(g1)\n    frame_dig -1\n    callsub _negate\n    // zorkin_contract_account/verifier.py:63\n    // negated_proof: Bytes = concat(_x(g1), negated_rhs)\n    frame_dig -1\n    callsub _x\n    swap\n    concat\n    // zorkin_contract_account/verifier.py:64\n    // return negated_proof\n    retsub\n\n\n// zorkin_contract_account.verifier._negate(g1: bytes) -> bytes:\n_negate:\n    // zorkin_contract_account/verifier.py:51-52\n    // @subroutine\n    // def _negate(g1: Bytes) -> Bytes:\n    proto 1 1\n    // zorkin_contract_account/verifier.py:53\n    // y: BigUInt = BigUInt.from_bytes(_y(g1))\n    frame_dig -1\n    callsub _y\n    // zorkin_contract_account/verifier.py:54\n    // b254_q_prime: BigUInt = BigUInt(B254_Q_PRIME)\n    byte 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n    // zorkin_contract_account/verifier.py:55\n    // z: BigUInt = b254_q_prime - (y % b254_q_prime)\n    b%\n    // zorkin_contract_account/verifier.py:54\n    // b254_q_prime: BigUInt = BigUInt(B254_Q_PRIME)\n    byte 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n    // zorkin_contract_account/verifier.py:55\n    // z: BigUInt = b254_q_prime - (y % b254_q_prime)\n    swap\n    b-\n    // zorkin_contract_account/verifier.py:56\n    // z_padded: Bytes = pad(z.bytes, UInt64(32))\n    int 32\n    callsub pad\n    // zorkin_contract_account/verifier.py:57\n    // return z_padded\n    retsub\n\n\n// zorkin_contract_account.verifier._y(g1: bytes) -> bytes:\n_y:\n    // zorkin_contract_account/verifier.py:46-47\n    // @subroutine\n    // def _y(g1: Bytes) -> Bytes:\n    proto 1 1\n    // zorkin_contract_account/verifier.py:48\n    // return extract(g1, KEY_SIZE, g1.length - KEY_SIZE)\n    frame_dig -1\n    len\n    int 32\n    -\n    frame_dig -1\n    int 32\n    uncover 2\n    extract3\n    retsub\n\n\n// zorkin_contract_account.common.pad(value: bytes, width: uint64) -> bytes:\npad:\n    // zorkin_contract_account/common.py:88-89\n    // @subroutine\n    // def pad(value: Bytes, width: UInt64) -> Bytes:\n    proto 2 1\n    // zorkin_contract_account/common.py:90\n    // assert value.length <= width, \"Width must be wider than value\"\n    frame_dig -2\n    len\n    dupn 2\n    frame_dig -1\n    <=\n    assert // Width must be wider than value\n    // zorkin_contract_account/common.py:91\n    // if value.length == width:\n    frame_dig -1\n    ==\n    bz pad_after_if_else@2\n    // zorkin_contract_account/common.py:92\n    // return value\n    frame_dig -2\n    swap\n    retsub\n\npad_after_if_else@2:\n    // zorkin_contract_account/common.py:93\n    // pad_length: UInt64 = width - value.length\n    frame_dig -1\n    frame_dig 0\n    -\n    // zorkin_contract_account/common.py:94\n    // padding: Bytes = bzero(pad_length)\n    bzero\n    // zorkin_contract_account/common.py:95\n    // padded: Bytes = concat(padding, value)\n    frame_dig -2\n    concat\n    // zorkin_contract_account/common.py:96\n    // return padded\n    swap\n    retsub\n\n\n// zorkin_contract_account.verifier._x(g1: bytes) -> bytes:\n_x:\n    // zorkin_contract_account/verifier.py:41-42\n    // @subroutine\n    // def _x(g1: Bytes) -> Bytes:\n    proto 1 1\n    // zorkin_contract_account/verifier.py:43\n    // return extract(g1, 0, KEY_SIZE)\n    frame_dig -1\n    extract 0 32\n    retsub\n";
export default _default;
//# sourceMappingURL=jwt_contents_proof_verifier.d.ts.map