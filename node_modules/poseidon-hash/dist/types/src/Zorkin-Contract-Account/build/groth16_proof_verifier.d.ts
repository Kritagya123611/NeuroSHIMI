declare const _default: "#pragma version 10\n\nzorkin_contract_account.contracts.groth16_proof_verifier.groth16_proof_verifier:\n    // contracts/groth16_proof_verifier.py:24-25\n    // # Unpack the input\n    // proof_a: Bytes = arg(0)\n    arg 0\n    // contracts/groth16_proof_verifier.py:21-22\n    // # LSIG Hardcoded GUID of the Zorkin Verifier\n    // verifier_params_hash: Bytes = TemplateVar[Bytes](\"VERIFIER_GUID\")\n    byte TMPL_VERIFIER_GUID\n    // contracts/groth16_proof_verifier.py:26\n    // proof_b: Bytes = arg(1)\n    arg 1\n    // contracts/groth16_proof_verifier.py:27\n    // proof_c: Bytes = arg(2)\n    arg 2\n    // contracts/groth16_proof_verifier.py:29\n    // input_data_from_notes: Bytes = aggregate_gtxn_notes()\n    callsub aggregate_gtxn_notes\n    // contracts/groth16_proof_verifier.py:34\n    // contract_account_params.verifier_params.bytes\n    dup\n    int 112\n    extract_uint16\n    swap\n    dup\n    len\n    swap\n    dup\n    dig 3\n    uncover 3\n    substring3\n    // contracts/groth16_proof_verifier.py:33-35\n    // verifier_params_bytes: Bytes = decode_dynamic_bytes(\n    //     contract_account_params.verifier_params.bytes\n    // )\n    callsub decode_dynamic_bytes\n    cover 2\n    // contracts/groth16_proof_verifier.py:38\n    // contract_account_params.public_input.bytes\n    dup\n    int 110\n    extract_uint16\n    uncover 2\n    substring3\n    // contracts/groth16_proof_verifier.py:37-39\n    // public_input: Bytes = decode_dynamic_bytes(\n    //     contract_account_params.public_input.bytes\n    // )\n    callsub decode_dynamic_bytes\n    cover 3\n    cover 4\n    uncover 5\n    cover 2\n    // contracts/groth16_proof_verifier.py:40-42\n    // proof_is_valid_for_verifier: bool = verify_proof(\n    //     verifier_params, verifier_params_hash, public_input, proof_a, proof_b, proof_c\n    // )\n    callsub verify_proof\n    pop\n    // contracts/groth16_proof_verifier.py:43\n    // assert proof_is_valid_for_verifier, \"Proof must be valid for specified verifier\"\n    dup\n    assert // Proof must be valid for specified verifier\n    // contracts/groth16_proof_verifier.py:44\n    // return proof_is_valid_for_verifier\n    return\n\n\n// common.aggregate_gtxn_notes() -> bytes:\naggregate_gtxn_notes:\n    // common.py:159-160\n    // @subroutine\n    // def aggregate_gtxn_notes() -> Bytes:\n    proto 0 1\n    // common.py:161\n    // data: Bytes = Bytes(b\"\")\n    byte 0x\n    // common.py:162\n    // group_size: UInt64 = Global.group_size\n    global GroupSize\n    // common.py:163\n    // for i in urange(group_size):\n    int 0\n\naggregate_gtxn_notes_for_header@1:\n    // common.py:163\n    // for i in urange(group_size):\n    frame_dig 2\n    frame_dig 1\n    <\n    bz aggregate_gtxn_notes_after_for@4\n    // common.py:164\n    // note: Bytes = gtxn.Transaction(i).note\n    frame_dig 2\n    dup\n    gtxns Note\n    // common.py:165\n    // data += note\n    frame_dig 0\n    swap\n    concat\n    frame_bury 0\n    // common.py:163\n    // for i in urange(group_size):\n    int 1\n    +\n    frame_bury 2\n    b aggregate_gtxn_notes_for_header@1\n\naggregate_gtxn_notes_after_for@4:\n    // common.py:166\n    // return data\n    retsub\n\n\n// common.decode_dynamic_bytes(value: bytes) -> bytes:\ndecode_dynamic_bytes:\n    // common.py:77-78\n    // @subroutine\n    // def decode_dynamic_bytes(value: Bytes) -> Bytes:\n    proto 1 1\n    // common.py:79\n    // return substring(value, 2, value.length)\n    frame_dig -1\n    len\n    frame_dig -1\n    int 2\n    uncover 2\n    substring3\n    retsub\n\n\n// verifier.verify_proof(verifier_params: bytes, verifier_params_integrity_hash: bytes, public_input: bytes, proof_a: bytes, proof_b: bytes, proof_c: bytes) -> uint64, bytes:\nverify_proof:\n    // verifier.py:70-78\n    // @subroutine\n    // def verify_proof(\n    //     verifier_params: VerifierParams,\n    //     verifier_params_integrity_hash: Bytes,\n    //     public_input: Bytes,\n    //     proof_a: Bytes,\n    //     proof_b: Bytes,\n    //     proof_c: Bytes,\n    // ) -> bool:\n    proto 6 2\n    // verifier.py:79\n    // vk_alpha: Bytes = verifier_params.alpha.bytes\n    frame_dig -6\n    extract 0 64 // on error: Index access is out of bounds\n    dup\n    // verifier.py:80\n    // vk_beta: Bytes = verifier_params.beta.bytes\n    frame_dig -6\n    extract 64 128 // on error: Index access is out of bounds\n    // verifier.py:81\n    // vk_gamma: Bytes = verifier_params.gamma.bytes\n    frame_dig -6\n    extract 192 128 // on error: Index access is out of bounds\n    // verifier.py:82\n    // vk_delta: Bytes = verifier_params.delta.bytes\n    frame_dig -6\n    int 320\n    int 128\n    extract3 // on error: Index access is out of bounds\n    // verifier.py:83\n    // vk_ic: Bytes = decode_dynamic_bytes(verifier_params.ic.bytes)\n    frame_dig -6\n    int 448\n    extract_uint16\n    frame_dig -6\n    len\n    frame_dig -6\n    cover 2\n    substring3\n    callsub decode_dynamic_bytes\n    dup\n    cover 3\n    cover 5\n    // verifier.py:85\n    // beta_gamma_delta: Bytes = concat(vk_beta, concat(vk_gamma, vk_delta))\n    concat\n    uncover 2\n    swap\n    concat\n    dup\n    cover 3\n    // verifier.py:87\n    // n_input: UInt64 = public_input.length // KEY_SIZE\n    frame_dig -4\n    len\n    int 32\n    /\n    cover 3\n    // verifier.py:91\n    // sha256(concat(concat(vk_alpha, beta_gamma_delta), vk_ic))\n    uncover 2\n    swap\n    concat\n    swap\n    concat\n    sha256\n    // verifier.py:89-93\n    // # Assert it's the specified verifier by comparing it to a known integrity hash\n    // vk_is_valid: bool = (\n    //     sha256(concat(concat(vk_alpha, beta_gamma_delta), vk_ic))\n    //     == verifier_params_integrity_hash\n    // )\n    frame_dig -5\n    // verifier.py:91-92\n    // sha256(concat(concat(vk_alpha, beta_gamma_delta), vk_ic))\n    // == verifier_params_integrity_hash\n    ==\n    // verifier.py:95-96\n    // # Get vk_x\n    // vk_x: Bytes = concat(bzero(32), bzero(32))\n    byte 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n    // verifier.py:97\n    // for i in urange(n_input):\n    int 0\n\nverify_proof_for_header@1:\n    // verifier.py:97\n    // for i in urange(n_input):\n    frame_dig 6\n    frame_dig 3\n    <\n    bz verify_proof_after_for@4\n    // verifier.py:103\n    // extract(vk_ic, KEY_SIZE * (i + 1) * 2, KEY_SIZE * 2),\n    frame_dig 6\n    dup\n    int 1\n    +\n    int 32\n    dig 1\n    *\n    int 2\n    *\n    frame_dig 1\n    swap\n    int 64\n    extract3\n    // verifier.py:104\n    // extract(public_input, KEY_SIZE * i, KEY_SIZE),\n    int 32\n    uncover 3\n    *\n    frame_dig -4\n    swap\n    int 32\n    extract3\n    // verifier.py:101-105\n    // EllipticCurve.scalar_mul(\n    //     EC.BN254g1,\n    //     extract(vk_ic, KEY_SIZE * (i + 1) * 2, KEY_SIZE * 2),\n    //     extract(public_input, KEY_SIZE * i, KEY_SIZE),\n    // ),\n    ec_scalar_mul BN254g1\n    // verifier.py:98-106\n    // vk_x = EllipticCurve.add(\n    //     EC.BN254g1,\n    //     vk_x,\n    //     EllipticCurve.scalar_mul(\n    //         EC.BN254g1,\n    //         extract(vk_ic, KEY_SIZE * (i + 1) * 2, KEY_SIZE * 2),\n    //         extract(public_input, KEY_SIZE * i, KEY_SIZE),\n    //     ),\n    // )\n    frame_dig 5\n    swap\n    ec_add BN254g1\n    frame_bury 5\n    frame_bury 6\n    b verify_proof_for_header@1\n\nverify_proof_after_for@4:\n    // verifier.py:107\n    // vk_x = EllipticCurve.add(EC.BN254g1, vk_x, extract(vk_ic, 0, KEY_SIZE * 2))\n    frame_dig 1\n    extract 0 64\n    frame_dig 5\n    swap\n    ec_add BN254g1\n    // verifier.py:109-110\n    // # Negate Proof\n    // negated_proof: Bytes = _negate_proof(proof_a)\n    frame_dig -3\n    callsub _negate_proof\n    // verifier.py:112-113\n    // # Verify Proof\n    // proof_b_with_params: Bytes = concat(proof_b, beta_gamma_delta)\n    frame_dig -2\n    frame_dig 2\n    concat\n    cover 2\n    // verifier.py:117\n    // concat(concat(negated_proof, vk_alpha), concat(vk_x, proof_c)),\n    frame_dig 0\n    concat\n    swap\n    frame_dig -1\n    concat\n    concat\n    // verifier.py:115-119\n    // verify_proof: bool = EllipticCurve.pairing_check(\n    //     EC.BN254g1,\n    //     concat(concat(negated_proof, vk_alpha), concat(vk_x, proof_c)),\n    //     proof_b_with_params,\n    // )\n    swap\n    ec_pairing_check BN254g1\n    // verifier.py:121\n    // return vk_is_valid and verify_proof\n    frame_dig 4\n    &&\n    frame_dig -6\n    frame_bury 1\n    frame_bury 0\n    retsub\n\n\n// verifier._negate_proof(g1: bytes) -> bytes:\n_negate_proof:\n    // verifier.py:63-64\n    // @subroutine\n    // def _negate_proof(g1: Bytes) -> Bytes:\n    proto 1 1\n    // verifier.py:65\n    // negated_rhs: Bytes = _negate(g1)\n    frame_dig -1\n    callsub _negate\n    // verifier.py:66\n    // negated_proof: Bytes = concat(_x(g1), negated_rhs)\n    frame_dig -1\n    callsub _x\n    swap\n    concat\n    // verifier.py:67\n    // return negated_proof\n    retsub\n\n\n// verifier._negate(g1: bytes) -> bytes:\n_negate:\n    // verifier.py:54-55\n    // @subroutine\n    // def _negate(g1: Bytes) -> Bytes:\n    proto 1 1\n    // verifier.py:56\n    // y: BigUInt = BigUInt.from_bytes(_y(g1))\n    frame_dig -1\n    callsub _y\n    // verifier.py:57\n    // b254_q_prime: BigUInt = BigUInt(B254_Q_PRIME)\n    byte 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n    // verifier.py:58\n    // z: BigUInt = b254_q_prime - (y % b254_q_prime)\n    b%\n    // verifier.py:57\n    // b254_q_prime: BigUInt = BigUInt(B254_Q_PRIME)\n    byte 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n    // verifier.py:58\n    // z: BigUInt = b254_q_prime - (y % b254_q_prime)\n    swap\n    b-\n    // verifier.py:59\n    // z_padded: Bytes = pad(z.bytes, UInt64(32))\n    int 32\n    callsub pad\n    // verifier.py:60\n    // return z_padded\n    retsub\n\n\n// verifier._y(g1: bytes) -> bytes:\n_y:\n    // verifier.py:49-50\n    // @subroutine\n    // def _y(g1: Bytes) -> Bytes:\n    proto 1 1\n    // verifier.py:51\n    // return extract(g1, KEY_SIZE, g1.length - KEY_SIZE)\n    frame_dig -1\n    len\n    int 32\n    -\n    frame_dig -1\n    int 32\n    uncover 2\n    extract3\n    retsub\n\n\n// common.pad(value: bytes, width: uint64) -> bytes:\npad:\n    // common.py:82-83\n    // @subroutine\n    // def pad(value: Bytes, width: UInt64) -> Bytes:\n    proto 2 1\n    // common.py:84\n    // assert value.length <= width, \"Width must be wider than value\"\n    frame_dig -2\n    len\n    dupn 2\n    frame_dig -1\n    <=\n    assert // Width must be wider than value\n    // common.py:85\n    // if value.length == width:\n    frame_dig -1\n    ==\n    bz pad_after_if_else@2\n    // common.py:86\n    // return value\n    frame_dig -2\n    swap\n    retsub\n\npad_after_if_else@2:\n    // common.py:87\n    // pad_length: UInt64 = width - value.length\n    frame_dig -1\n    frame_dig 0\n    -\n    // common.py:88\n    // padding: Bytes = bzero(pad_length)\n    bzero\n    // common.py:89\n    // padded: Bytes = concat(padding, value)\n    frame_dig -2\n    concat\n    // common.py:90\n    // return padded\n    swap\n    retsub\n\n\n// verifier._x(g1: bytes) -> bytes:\n_x:\n    // verifier.py:44-45\n    // @subroutine\n    // def _x(g1: Bytes) -> Bytes:\n    proto 1 1\n    // verifier.py:46\n    // return extract(g1, 0, KEY_SIZE)\n    frame_dig -1\n    extract 0 32\n    retsub\n";
export default _default;
//# sourceMappingURL=groth16_proof_verifier.d.ts.map